<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DevTrader Trading Journal</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Orbitron -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    
    <!-- React & Babel for running the component -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Three.js for 3D graphics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* Apply the Orbitron font family */
        body {
            font-family: 'Orbitron', sans-serif;
            overscroll-behavior-y: none;
            cursor: default;
        }
        /* Style for number input arrows */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
          -webkit-appearance: none; 
          margin: 0; 
        }
        input[type=number] {
          -moz-appearance: textfield;
        }
        /* Ensure canvas is behind everything */
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        /* Required for 3D transform effects on child elements */
        .perspective-container {
            perspective: 1500px;
        }
        .transform-style-3d {
            transform-style: preserve-3d;
        }
        /* Animation for today's highlight */
        @keyframes pulse-glow-cyber {
            0%, 100% { box-shadow: 0 0 10px 3px rgba(234, 179, 8, 0.8), inset 0 0 5px 1px rgba(234, 179, 8, 0.5); }
            50% { box-shadow: 0 0 20px 6px rgba(234, 179, 8, 0.5), inset 0 0 10px 2px rgba(234, 179, 8, 0.3); }
        }
        .today-highlight {
            animation: pulse-glow-cyber 2.5s infinite;
        }
        
        .day-container {
             cursor: grab;
        }
        /* Class applied during drag-to-rotate interaction */
        .is-dragging {
            animation: none !important;
            cursor: grabbing;
        }
        /* Scanlines overlay for cyberpunk feel */
        .scanlines::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 1;
            background-size: 100% 3px, 4px 100%;
            pointer-events: none;
            animation: flicker 0.15s infinite;
            opacity: 0.5;
        }
        .dark .scanlines::before {
             opacity: 1;
        }
        @keyframes flicker {
            0% { opacity: 0.8; }
            50% { opacity: 0.9; }
            100% { opacity: 0.8; }
        }
    </style>
    <script>
        // Tailwind dark mode configuration
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
</head>
<!-- The body tag is now clean, React will handle the background -->
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useMemo, useRef } = React;
        
        // --- Constants and Configuration ---
        const DEFAULT_INITIAL_CAPITAL = 50000;
        const DEFAULT_FINAL_TARGET = 1000000;
        const DEFAULT_TENURE_DAYS = 66; 
        const TRADING_DAYS_PER_MONTH = 22;

        const DEFAULT_RULES = [
            { text: "MAINTAIN DISCIPLINE: ADHERE TO THE PLAN", checked: false },
            { text: "VALIDATE STRATEGY: CONFIRM ENTRY/EXIT CRITERIA", checked: false },
            { text: "ASSESS MACRO TREND: CONSULT HIGHER TIMEFRAMES", checked: false },
            { text: "RISK PROTOCOL: MAX 2% CAPITAL PER ENGAGEMENT", checked: false },
            { text: "PROTECT CAPITAL: NEVER SHIFT STOP-LOSS MID-TRADE", checked: false },
            { text: "DEFINE LOSS LIMITS: SET DAILY DRAWDOWN THRESHOLD", checked: false },
            { text: "AVOID EMOTIONAL TRADING: NO REVENGE/OVER-TRADING", checked: false },
            { text: "MAINTAIN OBJECTIVITY: LOGIC OVER FEAR/GREED", checked: false },
            { text: "POST-TRADE ANALYSIS: LOG & REVIEW ALL EXECUTIONS", checked: false },
            { text: "OPERATOR STATUS: CONFIRM PEAK MENTAL & PHYSICAL STATE", checked: false },
        ];
        
        // --- Helper Functions ---
        const getNextTradingDay = (date) => {
            const nextDay = new Date(date);
            nextDay.setDate(nextDay.getDate() + 1);
            while (nextDay.getDay() === 0 || nextDay.getDay() === 6) { 
                nextDay.setDate(nextDay.getDate() + 1);
            }
            return nextDay;
        };
        
        const getTodayDateString = () => {
            const today = new Date();
            return today.toISOString().split('T')[0];
        }

        const formatNumber = (num) => {
            const number = Number(num);
            if (isNaN(number)) return '0';
            if (Math.abs(number) >= 10000000) {
                return (number / 10000000).toFixed(2).replace(/\.00$/, '') + ' CR';
            }
            if (Math.abs(number) >= 100000) {
                return (number / 100000).toFixed(2).replace(/\.00$/, '') + ' L';
            }
            if (Math.abs(number) >= 1000) {
                return (number / 1000).toFixed(2).replace(/\.00$/, '') + ' K';
            }
            return number.toLocaleString('en-IN');
        };

        // --- 3D Background Component ---
        const DynamicBackground = ({ theme }) => {
            const mountRef = useRef(null);

            useEffect(() => {
                const currentMount = mountRef.current;
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, currentMount.clientWidth / currentMount.clientHeight, 0.1, 1000);
                camera.position.z = 25;
                camera.position.y = 5;
                
                const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
                currentMount.appendChild(renderer.domElement);

                // Theme-dependent setup
                const isDark = theme === 'dark';
                scene.fog = isDark ? new THREE.FogExp2(0x000000, 0.015) : new THREE.FogExp2(0xaaaaaa, 0.01);
                const ambientLight = new THREE.AmbientLight(0xffffff, isDark ? 0.1 : 0.5);
                scene.add(ambientLight);
                
                const magentaLight = new THREE.PointLight(0xff00ff, isDark ? 1 : 0.5, 100);
                magentaLight.position.set(-20, 10, 0);
                scene.add(magentaLight);

                const cyanLight = new THREE.PointLight(0x00ffff, isDark ? 1 : 0.5, 100);
                cyanLight.position.set(20, 10, 0);
                scene.add(cyanLight);

                const gridHelper = new THREE.GridHelper(200, 50, isDark ? 0x00ffff : 0x555555, isDark ? 0x555555 : 0xcccccc);
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = isDark ? 0.5 : 0.25;
                scene.add(gridHelper);
                
                const dataTowers = [];
                const towerGroup = new THREE.Group();
                for (let i = 0; i < 70; i++) {
                    const isCyan = Math.random() > 0.5;
                    const material = new THREE.MeshStandardMaterial({ 
                        color: isCyan ? 0x00ffff : 0xff00ff, 
                        emissive: isDark ? (isCyan ? 0x00ffff : 0xff00ff) : 0x000000,
                        emissiveIntensity: isDark ? 0.5 : 0,
                        metalness: 0.8,
                        roughness: 0.4
                    });
                    const geometry = new THREE.BoxGeometry(0.8, Math.random() * 15 + 2, 0.8);
                    const tower = new THREE.Mesh(geometry, material);
                    tower.position.x = (Math.random() - 0.5) * 180;
                    tower.position.z = (Math.random() - 0.5) * 180;
                    tower.scale.y = Math.random();
                    towerGroup.add(tower);
                    dataTowers.push(tower);
                }
                scene.add(towerGroup);

                const particlesGeometry = new THREE.BufferGeometry();
                const particlesCnt = 8000;
                const posArray = new Float32Array(particlesCnt * 3);
                for (let i = 0; i < particlesCnt * 3; i++) posArray[i] = (Math.random() - 0.5) * 200;
                particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const particlesMaterial = new THREE.PointsMaterial({ 
                    size: 0.1, 
                    color: isDark ? 0x00ff00 : 0x333333,
                    transparent: true, opacity: 0.7
                });
                const particles = new THREE.Points(particlesGeometry, particlesMaterial);
                scene.add(particles);

                // Rotating Icosahedrons
                const geo = new THREE.IcosahedronGeometry(2, 0);
                const mat = new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0, metalness: 0.5, wireframe: true});
                const wireframe1 = new THREE.Mesh(geo, mat);
                wireframe1.position.set(-20, 10, -20);
                scene.add(wireframe1);
                 const wireframe2 = new THREE.Mesh(geo, mat);
                wireframe2.position.set(20, 10, -20);
                scene.add(wireframe2);

                const clock = new THREE.Clock();
                const animate = () => {
                    const elapsedTime = clock.getElapsedTime();
                    dataTowers.forEach(c => c.scale.y = (Math.sin(elapsedTime * 0.8 + c.position.x) + 1) / 2 * 0.9 + 0.1);
                    particles.position.y = (elapsedTime * -5) % 100;
                    
                    camera.position.x = Math.sin(elapsedTime * 0.1) * 10;
                    camera.position.y = 5 + Math.cos(elapsedTime * 0.15) * 4;
                    camera.lookAt(scene.position);
                    
                    wireframe1.rotation.y += 0.005;
                    wireframe1.rotation.x += 0.005;
                    wireframe2.rotation.y -= 0.005;
                    wireframe2.rotation.x -= 0.005;


                    renderer.render(scene, camera);
                    requestAnimationFrame(animate);
                };
                animate();

                const handleResize = () => {
                    camera.aspect = currentMount.clientWidth / currentMount.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(currentMount.clientWidth, currentMount.clientHeight);
                };
                window.addEventListener('resize', handleResize);
                return () => {
                    window.removeEventListener('resize', handleResize);
                    currentMount.removeChild(renderer.domElement);
                };
            }, [theme]);
            return <div ref={mountRef} id="bg-canvas" />;
        };

        // --- Main React App Component ---
        function App() {
            const [data, setData] = useState(null);
            const [activeMonthIndex, setActiveMonthIndex] = useState(0);
            const [todayString, setTodayString] = useState(getTodayDateString());
            const [theme, setTheme] = useState(() => localStorage.getItem("theme") || "dark");

            const [inputCapital, setInputCapital] = useState(DEFAULT_INITIAL_CAPITAL.toString());
            const [inputTarget, setInputTarget] = useState(DEFAULT_FINAL_TARGET.toString());
            const [inputTenure, setInputTenure] = useState(DEFAULT_TENURE_DAYS.toString());

            const dragInfo = useRef(null);

            const generatePlanStructure = useCallback((tenure, oldMonths = []) => {
                const oldDaysMap = new Map();
                oldMonths.forEach(month => month.days.forEach(day => oldDaysMap.set(day.date, day)));

                let months = [];
                let currentDate = new Date();
                let dayCounter = 0;

                while (dayCounter < tenure) {
                    const monthIndex = Math.floor(dayCounter / TRADING_DAYS_PER_MONTH);
                    if (!months[monthIndex]) {
                        months[monthIndex] = {
                            id: monthIndex + 1,
                            monthName: currentDate.toLocaleString('default', { month: 'long', year: 'numeric' }),
                            days: []
                        };
                    }
                    
                    const dateStr = currentDate.toISOString().split('T')[0];
                    const existingDayData = oldDaysMap.get(dateStr);

                    months[monthIndex].days.push({
                        day: dayCounter + 1,
                        date: dateStr,
                        capital: 0, target: 0, profit: 0, dailyRate: 0,
                        achieved: existingDayData ? existingDayData.achieved : false,
                        pnlSign: existingDayData ? existingDayData.pnlSign : "+",
                        actual: existingDayData ? existingDayData.actual : "",
                        winningTrades: existingDayData ? existingDayData.winningTrades : "",
                        losingTrades: existingDayData ? existingDayData.losingTrades : "",
                        logic: existingDayData ? existingDayData.logic : "",
                        rules: existingDayData ? existingDayData.rules : JSON.parse(JSON.stringify(DEFAULT_RULES)),
                    });

                    currentDate = getNextTradingDay(currentDate);
                    dayCounter++;
                }
                return months;
            }, []);
            
            const recalculatePlan = useCallback((fullData) => {
                const { initialCapital, finalTarget, tenure } = fullData;
                const newMonths = JSON.parse(JSON.stringify(fullData.months));
                const allDays = newMonths.flatMap(m => m.days);

                const initialDailyRate = Math.pow(finalTarget / initialCapital, 1 / tenure) - 1;
                let plannedCapital = initialCapital;
                const plannedGoals = [];
                for (let i = 0; i < tenure; i++) {
                    const plannedTarget = plannedCapital * (1 + initialDailyRate);
                    const plannedProfit = plannedTarget - plannedCapital;
                    plannedGoals.push({ target: Math.round(plannedTarget), profit: Math.round(plannedProfit) });
                    plannedCapital = plannedTarget;
                }

                let actualCapital = initialCapital;
                let totalDaysElapsed = 0;

                for (let day of allDays) {
                    day.target = plannedGoals[totalDaysElapsed].target;
                    day.profit = plannedGoals[totalDaysElapsed].profit;
                    day.capital = Math.round(actualCapital);
                    
                    if (actualCapital > 0 && day.target > actualCapital) {
                        day.dailyRate = (day.target / actualCapital) - 1;
                    } else {
                        day.dailyRate = 0;
                    }
                    
                    if (day.actual !== "") {
                        const actualProfit = Number(day.actual) || 0;
                        const signedProfit = day.pnlSign === '+' ? actualProfit : -actualProfit;
                        actualCapital += signedProfit;
                    } else {
                        actualCapital = day.target;
                    }
                    totalDaysElapsed++;
                }
                return newMonths;
            }, []);
            
            useEffect(() => {
                try {
                    const savedData = localStorage.getItem("tradingChallengeData");
                    if (savedData) {
                        const parsedData = JSON.parse(savedData);
                        setData(parsedData);
                        setInputCapital(parsedData.initialCapital.toString());
                        setInputTarget(parsedData.finalTarget.toString());
                        setInputTenure(parsedData.tenure.toString());
                    } else {
                        const initialTenure = DEFAULT_TENURE_DAYS;
                        const months = generatePlanStructure(initialTenure);
                        let initialData = { 
                            initialCapital: DEFAULT_INITIAL_CAPITAL, 
                            finalTarget: DEFAULT_FINAL_TARGET, 
                            tenure: initialTenure,
                            months: months 
                        };
                        initialData.months = recalculatePlan(initialData);
                        setData(initialData);
                        localStorage.setItem("tradingChallengeData", JSON.stringify(initialData));
                    }
                } catch (error) { console.error("Failed to initialize data:", error); }
            }, [generatePlanStructure, recalculatePlan]);

            useEffect(() => {
                document.documentElement.classList.toggle("dark", theme === "dark");
                localStorage.setItem("theme", theme);
            }, [theme]);
            
            const handleUpdateTargets = () => {
                const newInitialCapital = parseInt(inputCapital, 10) || DEFAULT_INITIAL_CAPITAL;
                const newFinalTarget = parseInt(inputTarget, 10) || DEFAULT_FINAL_TARGET;
                const newTenure = parseInt(inputTenure, 10) || DEFAULT_TENURE_DAYS;

                setData(prevData => {
                    const newMonths = generatePlanStructure(newTenure, prevData.months);
                    const updatedData = {
                        ...prevData,
                        initialCapital: newInitialCapital,
                        finalTarget: newFinalTarget,
                        tenure: newTenure,
                        months: newMonths,
                    };
                    updatedData.months = recalculatePlan(updatedData);
                    localStorage.setItem("tradingChallengeData", JSON.stringify(updatedData));
                    setActiveMonthIndex(0);
                    return updatedData;
                });
            };

            const handleProfitInput = (monthIndex, dayIndex, value) => {
                setData(prevData => {
                    const newData = JSON.parse(JSON.stringify(prevData));
                    const day = newData.months[monthIndex].days[dayIndex];
                    day.actual = value;
                    const actualProfit = Number(value) || 0;
                    const signedProfit = day.pnlSign === '+' ? actualProfit : -actualProfit;
                    day.achieved = signedProfit >= day.profit;
                    newData.months = recalculatePlan(newData);
                    localStorage.setItem("tradingChallengeData", JSON.stringify(newData));
                    return newData;
                });
            };
            
            const handleSignChange = (monthIndex, dayIndex, sign) => {
                 setData(prevData => {
                    const newData = JSON.parse(JSON.stringify(prevData));
                    const day = newData.months[monthIndex].days[dayIndex];
                    day.pnlSign = sign;
                    const actualProfit = Number(day.actual) || 0;
                    const signedProfit = sign === '+' ? actualProfit : -actualProfit;
                    day.achieved = signedProfit >= day.profit;
                    newData.months = recalculatePlan(newData);
                    localStorage.setItem("tradingChallengeData", JSON.stringify(newData));
                    return newData;
                });
            };

            const handleDetailsChange = (monthIndex, dayIndex, field, value) => {
                 setData(prevData => {
                    const newData = JSON.parse(JSON.stringify(prevData));
                    newData.months[monthIndex].days[dayIndex][field] = value;
                    localStorage.setItem("tradingChallengeData", JSON.stringify(newData));
                    return newData;
                });
            };

            const handleRuleChange = (monthIndex, dayIndex, ruleIndex, isChecked) => {
                setData(prevData => {
                    const newData = JSON.parse(JSON.stringify(prevData));
                    newData.months[monthIndex].days[dayIndex].rules[ruleIndex].checked = isChecked;
                    localStorage.setItem("tradingChallengeData", JSON.stringify(newData));
                    return newData;
                });
            };
            
            const handleResetChallenge = () => {
                if (confirm("::: CRITICAL WARNING :::\nResetting the entire challenge will purge all archived data and reset goals to default. Proceed with caution.")) {
                    localStorage.removeItem("tradingChallengeData");
                    window.location.reload();
                }
            };
            
            const handleAddNewMonth = () => {
                setData(prevData => {
                    const newTenure = prevData.tenure + TRADING_DAYS_PER_MONTH;
                    const newMonths = generatePlanStructure(newTenure, prevData.months);
                    const updatedData = {
                        ...prevData,
                        tenure: newTenure,
                        months: newMonths
                    };
                    updatedData.months = recalculatePlan(updatedData);
                    localStorage.setItem("tradingChallengeData", JSON.stringify(updatedData));
                    setInputTenure(newTenure.toString());
                    return updatedData;
                });
            };

            const toggleTheme = () => setTheme(prev => prev === "dark" ? "light" : "dark");
            
            // --- Drag-to-Rotate Handlers ---
            const handleMouseMove = useCallback((e) => {
                if (!dragInfo.current) return;
                const { element, startX, startY } = dragInfo.current;
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                element.style.transform = `rotateX(${-deltaY * 0.2}deg) rotateY(${deltaX * 0.2}deg) scale3d(1.05, 1.05, 1.05)`;
            }, []);

            const handleMouseUp = useCallback(() => {
                if (!dragInfo.current) return;
                dragInfo.current.element.classList.remove('is-dragging');
                dragInfo.current.element.style.transform = ''; 
                window.removeEventListener('mousemove', handleMouseMove);
                window.removeEventListener('mouseup', handleMouseUp);
                dragInfo.current = null;
            }, [handleMouseMove]);

            const handleMouseDown = useCallback((e) => {
                if (e.button !== 0 || ['INPUT', 'TEXTAREA', 'LABEL', 'BUTTON'].includes(e.target.tagName) || e.target.closest('label')) return;
                const element = e.currentTarget;
                element.classList.add('is-dragging');
                dragInfo.current = { element, startX: e.clientX, startY: e.clientY };
                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);
            }, [handleMouseMove, handleMouseUp]);

            const analysis = useMemo(() => {
                if (!data || !data.months[activeMonthIndex]) return { pnl: 0, profitDays: 0, lossDays: 0, winningTrades: 0, losingTrades: 0 };
                const month = data.months[activeMonthIndex];
                const completedDays = month.days.filter(d => d.actual !== "");
                const pnl = completedDays.reduce((acc, day) => {
                    const value = Number(day.actual) || 0;
                    return acc + (day.pnlSign === '+' ? value : -value);
                }, 0);
                const profitDays = completedDays.filter(d => (d.pnlSign === '+' && d.actual !== '0') || (d.pnlSign === '-' && Number(d.actual) < 0)).length;
                const lossDays = completedDays.filter(d => (d.pnlSign === '-' && d.actual !== '0') || (d.pnlSign === '+' && Number(d.actual) < 0)).length;
                const winningTrades = completedDays.reduce((acc, day) => acc + (Number(day.winningTrades) || 0), 0);
                const losingTrades = completedDays.reduce((acc, day) => acc + (Number(day.losingTrades) || 0), 0);
                return { pnl, profitDays, lossDays, winningTrades, losingTrades };
            }, [data, activeMonthIndex]);

            const startCapitalForMonth = useMemo(() => {
                if (!data || activeMonthIndex === 0) return data ? data.initialCapital : 0;
                const allDays = data.months.flatMap(m => m.days);
                const firstDayOfMonthIndex = activeMonthIndex * TRADING_DAYS_PER_MONTH;
                return allDays[firstDayOfMonthIndex] ? allDays[firstDayOfMonthIndex].capital : 0;
            }, [data, activeMonthIndex]);
            
            if (!data) {
                return <div className="min-h-screen flex items-center justify-center text-cyan-400"><p>LOADING NEURAL INTERFACE...</p></div>
            }
            
            const currentMonthData = data.months[activeMonthIndex];
            
            return (
                <div className="relative min-h-screen bg-gray-100 dark:bg-black text-gray-800 dark:text-gray-200 flex flex-col items-center p-4 sm:p-6 scanlines transition-colors duration-500">
                    <DynamicBackground theme={theme} />

                     <button onClick={toggleTheme} className="absolute top-4 right-4 sm:top-6 sm:right-6 px-4 py-2 rounded-lg bg-white/50 dark:bg-black/70 backdrop-blur-sm text-gray-800 dark:text-gray-200 hover:bg-white/80 dark:hover:bg-black/90 focus:outline-none focus:ring-2 focus:ring-cyan-400 z-10">
                        {theme === "dark" ? "Light" : "Dark"}
                    </button>
                    
                    <header className="text-center w-full max-w-7xl z-10">
                        <h1 className="text-2xl sm:text-4xl font-black mb-2 text-cyan-600 dark:text-cyan-400" style={{textShadow: '0 0 10px #00ffff'}}>
                            DevTrader Trading Journal
                        </h1>
                        <p className="font-bold tracking-wider text-gray-500 dark:text-gray-300 mb-2 drop-shadow">
                            OBJECTIVE: ₹{formatNumber(data.initialCapital, false)} → ₹{formatNumber(data.finalTarget, false)} in {data.tenure} days
                        </p>
                    </header>
                    
                    <div className="w-full max-w-5xl my-4 p-4 z-10 bg-white/50 dark:bg-black/70 backdrop-blur-sm border border-cyan-700/30 dark:border-cyan-500/50 shadow-[0_0_15px_rgba(0,255,255,0.3)]">
                        <div className="flex flex-col sm:flex-row justify-center items-center gap-4">
                            <div className="flex flex-col items-center">
                                <label className="text-xs text-gray-500 dark:text-gray-400 mb-1">START CAPITAL</label>
                                 <div className="flex items-center bg-white/50 dark:bg-black/50 border border-cyan-700/30 dark:border-cyan-500/50 focus-within:ring-2 focus-within:ring-cyan-400">
                                    <span className="px-2 text-gray-500">₹</span>
                                    <input type="number" value={inputCapital} onChange={e => setInputCapital(e.target.value)} className="bg-transparent text-center p-2 w-40 focus:outline-none" />
                                </div>
                            </div>
                            <div className="flex flex-col items-center">
                                <label className="text-xs text-gray-500 dark:text-gray-400 mb-1">OVERALL TARGET</label>
                                <div className="flex items-center bg-white/50 dark:bg-black/50 border border-cyan-700/30 dark:border-cyan-500/50 focus-within:ring-2 focus-within:ring-cyan-400">
                                    <span className="px-2 text-gray-500">₹</span>
                                    <input type="number" value={inputTarget} onChange={e => setInputTarget(e.target.value)} className="bg-transparent text-center p-2 w-40 focus:outline-none" />
                                </div>
                            </div>
                             <div className="flex flex-col items-center">
                                <label className="text-xs text-gray-500 dark:text-gray-400 mb-1">TENURE (DAYS)</label>
                                <input type="number" value={inputTenure} onChange={e => setInputTenure(e.target.value)} className="bg-white/50 dark:bg-black/50 border border-cyan-700/30 dark:border-cyan-500/50 text-center p-2 w-48 focus:outline-none focus:ring-2 focus:ring-cyan-400" />
                            </div>
                             <button onClick={handleUpdateTargets} className="bg-cyan-600/80 hover:bg-cyan-500/80 border border-cyan-400 backdrop-blur-sm text-white px-6 py-2 mt-2 sm:mt-5 font-bold shadow-[0_0_10px_rgba(0,255,255,0.5)] transition-all">SET & RECALCULATE</button>
                        </div>
                    </div>
                    
                    <div className="w-full max-w-7xl mb-4 bg-white/50 dark:bg-black/70 backdrop-blur-sm rounded-t-lg z-10 border-t border-x border-cyan-700/30 dark:border-cyan-500/50 shadow-[0_0_15px_rgba(0,255,255,0.3)]">
                        <div className="flex overflow-x-auto">
                            {data.months.map((month, index) => (
                                <button
                                    key={month.id} onClick={() => setActiveMonthIndex(index)}
                                    className={`px-4 py-2 text-xs sm:text-sm font-bold transition-all whitespace-nowrap border-b-2 ${activeMonthIndex === index ? 'border-cyan-500 text-cyan-600 dark:border-cyan-400 dark:text-cyan-400' : 'border-transparent text-gray-600 dark:text-gray-400 hover:text-cyan-600 dark:hover:text-cyan-400 hover:bg-cyan-900/20'}`}
                                >
                                    &gt; {month.monthName || `Month ${month.id}`}
                                </button>
                            ))}
                        </div>
                    </div>
                    
                    <div className="w-full max-w-7xl grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 mb-4 text-center z-10">
                        {['MONTH P&L', 'PROFIT DAYS', 'LOSS DAYS', 'WINNING TRADES', 'LOSING TRADES', 'MONTH START'].map((title, i) => (
                            <div key={title} className="bg-white/50 dark:bg-black/70 backdrop-blur-sm p-4 border border-fuchsia-700/30 dark:border-fuchsia-500/50 shadow-[0_0_15px_rgba(255,0,255,0.3)]">
                                <h4 className="text-xs sm:text-sm font-semibold text-gray-500 dark:text-gray-400">{title}</h4>
                                <p className={`text-lg sm:text-xl font-bold ${i === 0 ? (analysis.pnl >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400') : i === 1 || i === 3 ? 'text-green-600 dark:text-green-400' : i === 2 || i === 4 ? 'text-red-600 dark:text-red-400' : 'text-gray-800 dark:text-gray-200'}`}>
                                    {i === 0 ? `₹${formatNumber(analysis.pnl, false)}` : i === 1 ? analysis.profitDays : i === 2 ? analysis.lossDays : i === 3 ? analysis.winningTrades : i === 4 ? analysis.losingTrades : '₹' + formatNumber(Math.round(startCapitalForMonth), false) }
                                </p>
                            </div>
                        ))}
                    </div>

                    <div className="w-full max-w-7xl perspective-container z-10">
                        <div className="space-y-6">
                            {currentMonthData && currentMonthData.days.map((row, i) => {
                                const isToday = row.date === todayString;
                                const pnlValue = Number(row.actual) || 0;
                                const isProfit = row.pnlSign === '+' && pnlValue > 0;
                                const isLoss = row.pnlSign === '-' && pnlValue > 0;
                                
                                return (
                                <div 
                                    key={row.date} 
                                    className={`day-container p-4 border transition-all duration-300 transform-style-3d hover:scale-[1.02] ${
                                        isProfit ? 'hover:!bg-green-400/20 dark:hover:!bg-green-900/50' : isLoss ? 'hover:!bg-red-400/20 dark:hover:!bg-red-900/50' : 'hover:!bg-gray-400/20 dark:hover:!bg-gray-800/40'
                                    } ${
                                        isToday ? 'today-highlight border-yellow-500/80' : 'border-cyan-700/20 dark:border-cyan-500/30'} ${
                                        isProfit ? "bg-green-200/30 dark:bg-green-800/30 backdrop-blur-md" : isLoss ? "bg-red-200/30 dark:bg-red-800/30 backdrop-blur-md" : "bg-white/50 dark:bg-black/70 backdrop-blur-md" }`}
                                    onMouseDown={handleMouseDown}
                                >
                                    {/* --- Top Data Row --- */}
                                    <div className="grid grid-cols-2 sm:grid-cols-4 lg:grid-cols-9 gap-4 items-center text-center">
                                        <div className="flex flex-col"><span className="text-xs text-gray-500 dark:text-gray-400">DAY</span><span className="font-black text-lg">{row.day}</span></div>
                                        <div className="flex flex-col"><span className="text-xs text-gray-500 dark:text-gray-400">DATE</span><span className="font-bold text-sm">{new Date(row.date).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}</span></div>
                                        <div className="flex flex-col"><span className="text-xs text-gray-500 dark:text-gray-400">CAPITAL</span><span className="font-mono font-bold">₹{formatNumber(row.capital, false)}</span></div>
                                        <div className="flex flex-col"><span className="text-xs text-gray-500 dark:text-gray-400">TARGET %</span><span className={`font-mono font-bold ${row.dailyRate > 0 ? 'text-cyan-700 dark:text-cyan-400' : 'text-gray-500'}`}>{(row.dailyRate * 100).toFixed(2)}%</span></div>
                                        <div className="flex flex-col"><span className="text-xs text-gray-500 dark:text-gray-400">PROFIT GOAL</span><span className="font-mono text-yellow-600 dark:text-yellow-400 font-bold">₹{formatNumber(row.profit, false)}</span></div>
                                        <div className="flex flex-col"><span className="text-xs text-gray-500 dark:text-gray-400">TARGET AMT</span><span className="font-mono font-bold">₹{formatNumber(row.target, false)}</span></div>
                                        <div className="flex flex-col items-center"><span className="text-xs text-gray-500 dark:text-gray-400 mb-1">WIN</span><input type="number" placeholder="W" value={row.winningTrades} onChange={(e) => handleDetailsChange(activeMonthIndex, i, 'winningTrades', e.target.value)} className="bg-white/50 dark:bg-black/50 border border-cyan-700/30 dark:border-cyan-500/50 text-center p-1.5 w-16 focus:outline-none focus:ring-2 focus:ring-cyan-400"/></div>
                                        <div className="flex flex-col items-center"><span className="text-xs text-gray-500 dark:text-gray-400 mb-1">LOSS</span><input type="number" placeholder="L" value={row.losingTrades} onChange={(e) => handleDetailsChange(activeMonthIndex, i, 'losingTrades', e.target.value)} className="bg-white/50 dark:bg-black/50 border border-cyan-700/30 dark:border-cyan-500/50 text-center p-1.5 w-16 focus:outline-none focus:ring-2 focus:ring-cyan-400"/></div>
                                        <div className="flex flex-col items-center">
                                            <span className="text-xs text-gray-500 dark:text-gray-400 mb-1">YOUR P&L</span>
                                            <div className="flex items-center">
                                                <button onClick={() => handleSignChange(activeMonthIndex, i, '+')} className={`px-2 py-1 border ${row.pnlSign === '+' ? 'bg-green-500 text-white border-green-500' : 'bg-transparent border-gray-500'}`}>+</button>
                                                <input type="number" placeholder="₹" value={row.actual} onChange={(e) => handleProfitInput(activeMonthIndex, i, e.target.value)} className="bg-white/50 dark:bg-black/50 border-y border-cyan-700/30 dark:border-cyan-500/50 text-center p-1.5 w-28 focus:outline-none focus:ring-2 focus:ring-cyan-400" />
                                                <button onClick={() => handleSignChange(activeMonthIndex, i, '-')} className={`px-2 py-1 border ${row.pnlSign === '-' ? 'bg-red-500 text-white border-red-500' : 'bg-transparent border-gray-500'}`}>-</button>
                                            </div>
                                        </div>
                                    </div>
                                    {/* --- Journal Section --- */}
                                    <div className="mt-4 pt-4 border-t border-cyan-700/20 dark:border-cyan-500/30">
                                         <div className="flex flex-col md:flex-row gap-6">
                                            <div className="flex-1 md:w-1/2">
                                                <h3 className="font-bold mb-2 text-left text-fuchsia-600 dark:text-fuchsia-400">DAILY PROTOCOLS</h3>
                                                <div className="space-y-2 text-left">
                                                    {row.rules.map((rule, ruleIndex) => (
                                                        <label key={ruleIndex} className="flex items-center text-xs sm:text-sm cursor-pointer group">
                                                            <input type="checkbox" checked={rule.checked} onChange={(e) => handleRuleChange(activeMonthIndex, i, ruleIndex, e.target.checked)} className="h-4 w-4 rounded-none border-2 border-fuchsia-700/50 dark:border-fuchsia-500/50 text-fuchsia-500 focus:ring-fuchsia-500 bg-transparent" />
                                                            <span className="ml-3 text-gray-700 dark:text-gray-300 group-hover:text-fuchsia-600 dark:group-hover:text-fuchsia-400 transition-colors">{rule.text}</span>
                                                        </label>
                                                    ))}
                                                </div>
                                            </div>
                                            <div className="flex-1 md:w-1/2">
                                                <h3 className="font-bold mb-2 text-left text-fuchsia-600 dark:text-fuchsia-400">EXECUTION LOG</h3>
                                                <textarea value={row.logic} onChange={(e) => handleDetailsChange(activeMonthIndex, i, 'logic', e.target.value)} placeholder={`// LOG FOR DAY ${row.day}...`} className="w-full h-48 p-2 bg-white/30 dark:bg-black/50 border border-fuchsia-700/30 dark:border-fuchsia-500/50 text-green-700 dark:text-green-400 rounded-none focus:outline-none focus:ring-2 focus:ring-fuchsia-500"></textarea>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                )
                            })}
                        </div>
                    </div>
                    
                    <div className="w-full max-w-7xl mt-6 flex flex-wrap justify-center gap-4 z-10">
                        <button onClick={handleAddNewMonth} className="bg-blue-600/80 hover:bg-blue-500/80 border border-blue-400 backdrop-blur-sm text-white px-6 py-2 font-bold shadow-[0_0_10px_rgba(59,130,246,0.5)] transition-all">ADD NEW MONTH</button>
                        <button onClick={handleResetChallenge} className="bg-red-600/80 hover:bg-red-500/80 border border-red-400 backdrop-blur-sm text-white px-6 py-2 font-bold shadow-[0_0_10px_rgba(239,68,68,0.5)] transition-all">PURGE & RESET CHALLENGE</button>
                    </div>
                </div>
            );
        }

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>

